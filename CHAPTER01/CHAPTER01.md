## 1.CHAPTER 01
<br>

### 1.0
- OpenGL은 애플리케이션이 그 하부에서 동작하는 장치의 그래픽스 서브시스템에 접근하고 제어하기 위해 사용하는 인터페이스
- 서브시스템에 대한 인터페이스를 표준화하면 이식성을 증대시킬 수 있고 소프트웨어 개발자들이 고품질의 제품을 생산하는 데 집중할 수 있음
- 이러한 표준화된 인터페이스를 <b>애플리케이션 프로그래밍 인터페이스(Application Programming Interface)</b>라고 부름
<br><br>

### 1.1 OpenGL과 그래픽스 파이프라인

- 고성능/대형 제품을 만들기 위해서 확장성과 병렬화가 필요
- 제품의 생산 단계를 중첩시킴으로써 숙련된 기술자이ㅡ 역량을 한 번에 한 작업에만 집중시킴
- 각 단계는 더 효율적이고, 전체 생산량은 높아짐
<br>
- 프로그램에서 만들어진 명령들이 OpenGL에 전달되고, 하부의 그래픽스 하드웨어로 보내짐
- 그래픽스 하드웨어는 각 명령을 가능한 한 빨리 그리고 효율적으로 원하는 결과로 만들어냄
- OpenGl도 할당받은 작업들을 병렬화할 수 있는 기본 단위로 분할함
- <b>파이프라인 분할</b>과 <b>병렬화</b>를 조합하여 사용함으로써 최신 그래픽 프로세서의 놀랄만한 성능을 이루어 낼 수 있음
<br>
- 애플리케이션과 그 하부의 그래픽스 서브시스템의 <b>추상화 레이어</b>를 제공하는 것이 OpenGL의 목표
- 추상화 레이어를 통해 그래픽스 프로레스 유닛(graphics process unit, GPU) 제작사가 어디인지, 어떻게 동작하는지, 성능이 어떤지 알 필요가 없음
<br>
- OpenGL의 설계 원칙은 너무 높지도 너무 낮지도 않은 추상화 수준의 균형을 이루는 것임
- 여러 제조사의 제품 간의 차이(또는 한 제조사의 여러 제품 간의 차이)를 감추어야 하며 화면 해상도, 프로세서 아키텍처, 설치된 운영체제 등의 차이도 감추어야 함
<br>
- GPU는 <b>쉐이더</b>라 불리는 작은 프로그램을 실행하는 쉐이더 코어(다수의 작은 프로그래밍 가능한 프로세서)로 이루어져 있음
- 각 코어는 상대적으로 처리량이 낮고, 쉐이더의 인스트럭션 하나를 여러 클록 사이클로 수행함
- 각 GPU는 수십에서 수천의 코어 수를 가지며, 이를 통합하여 어마어마한 양의 일을 수행할 수 있음
- 그래픽스 시스템은 여러 <b>스테이지(stage, 단계)</b>로 나뉨
- 각 스테이지는 쉐이더나 설정 가능한 프로세싱 블록인 고정 함수로 구분됨
    - <U>그래픽스 파이프 라인의 단순화된 구조</U>
    - <I>버텍스 패치</I>
    - <I>버텍스 쉐이더</I>
    - <I>테셀레이션 컨트롤 쉐이더</I>
    - <U>테셀레이션</U>
    - <I>테셀레이션 이벨류에이션 쉐이더</I>
    - <I>지오메트리 쉐이더</I>
    - <U>래스터라이제이션</U>
    - <I>프래그먼트 쉐이더</I>
    - <U>프레임버퍼동작</U>
    - <i>고정 함수 스테이지(italic)</i> / <u>프로그래밍 가능 스테이지(underline)</u>
<br><br>

### 1.2 OpenGL의 기원과 진화
- 실리콘 그래픽스 주식회사(SGI)의 IRIS GL로 시작되었음
- 그래픽스 라이브러리(Graphics Library, GL)
- SGI는 이식성이 중요하다는 것을 깨닫고 IRIS GL을 정돈하고, API에서 시스템 의존적인 부분을 제거하고, 누구나 로열티 없이 사용할 수 있고 구현할 수 있도록 공개 표준으로 릴리즈했음
- 1992년 6월 OpenGL 1.0 릴리즈

#### 1.2.1 OpenGL 코어 프로파일
- 2008년에 OpenGL을 두 가지 <b>프로파일</b>로 분리
    - <b>코어</b> 프로파일(core profile, 핵심 프로파일)
        - 현대 그래픽스 하드웨어로 가속하지 못하는 많은 기존 기능을 제거함
        - 다른 버전인 <b>호환성</b> 프로파일(compatibility profile)에 비해 수백 페이지나 더 적음
    - 호환성 프로파일(compatibility profile)
        - OpenGL version 1.0까지의 모든 버전과의 하위 호환성을 유지함
        - 1992년도에 작성한 소프트웨어도 당시보다 수천 배 더 고성능의 최신 그래픽스 카드에서 컴파일되고 실행됨
<br>
- 기존 애플리케이션을 유지 보수할 때 새로운 API를 사용하기 위해 수년 동안의 작업을 제거하지 않아도 되도록 하기 위해 호환성 프로파일이 존재
- 새로운 애플리케이션을 개발할 때는 코어 프로파일 사용이 강력히 권고됨
    - 특정 플랫폼에서의 새로운 기능은 코어 프로파일을 사용해야 가능한 경우가 있음
    - 동일한 소스 코드라도 호환성 프로파일보다 코어 프로파일을 사용하도록 한 경우가 더 빠름
    - 호환성 프로파일에는 남아 있지만 코어 프로파일에서는 제거된 기능들은 충분한 이유로 그렇게 된 것이므로, 그 기능을 사용하지 않는 것이 바람직함
<br><br>

### 1.3 프리미티브, 파이프라인, 픽셀
- OpenGL은 생산라인의 모델을 따름
- 데이터는 단방향임
- <b>버퍼</b>나 <b>텍스터</b> 등의 자료구조는 렌더링 시에 사용할 정보를 저장하는 용도
- 파이프라인의 특정 스테이지에서는 이러한 버퍼나 텍스처에 데이터를 저장하기도 하는데, 이를 통해 애플리케이션이 데이터를 읽거나, 저장하거나, 저장한 데이터를 다시 읽을 수도 있음
<br>
- OpenGL 렌더링의 기본 단위는 <b>프리미티브(primitive)</b>
- 세 가지 기본 렌더링 가능 타입은 점, 선, 삼각형
- 복잡한 서피스를 많은 수의 삼각형으로 분할하고, OpenGL로 보내서 <b>래스터라이저(rasterizer)</b>라고 불리는 하드웨어 가속기를 사용하여 렌더링함
- 삼각형은 항상 <b>컨벡스(convex, 볼록)</b>하기 때문에 폴리곤을 그리는 규칙을 만들기도 쉽고 구현하기도 쉬움
- 컨케이브(concave, 오목)한 폴리곤은 둘 이상의 삼각형으로 분할할 수 있기 때문에, 하드웨어는 삼각형 렌더링을 직접 지원하며, 다른 서브시스템들을 통해 복잡한 지오메트리를 삼각형으로 분할할 수 있음
<br>
- 점, 선, 삼각형은 각각 하나, 둘, 세 개의 점으로 이루어짐
- <b>버텍스(vertex)</b>는 단순히 좌표 공간상(보통 3차원 좌표계를 의미함)의 하나의 점임
- 그래픽스 파이프라인은 두 개의 주요 파트로 분할됨
    - <b>프론트엔드(front end)</b>
        - 버텍스와 프리미티브를 처리하여 점, 선, 삼각형으로 구성하고 이들을 래스터라이저에 보내는 역할
        - <b>프리미티브 어셈블리(primitive assembly)</b>라고도 함
        - 래스터라이저 이후에는 지오메트리가 벡터 형태에서 대량의 각각의 픽셀로 변환됨
        - 이들은 <b>백엔드(back end)</b>로 전달됨
    - 백엔드
        - 깊이 및 스텐실 테스트, 프래그먼트 쉐이딩, 블렌딩, 출력 이미지 갱신 등의 작업
<br><br>

### 1.4 마치며
- OpenGL 소개, 기원, 역사, 상태, 방향 등
- OpenGL 파이프라인, 책의 진행 방법 등

<i>v1. 2019-04-04</i>
